package cloud.catfish.mbg.plugin;

import org.mybatis.generator.api.IntrospectedColumn;
import org.mybatis.generator.api.IntrospectedTable;
import org.mybatis.generator.api.PluginAdapter;
import org.mybatis.generator.api.dom.java.Field;
import org.mybatis.generator.api.dom.java.FullyQualifiedJavaType;
import org.mybatis.generator.api.dom.java.TopLevelClass;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;
import java.util.Properties;

/**
 * MyBatis Generator plugin for generating Request Parameter classes
 * for receiving query conditions from web pages.
 * 
 * <p>This plugin automatically generates:</p>
 * <ul>
 *   <li><strong>RequestParam Classes:</strong> Java classes for receiving query parameters from web requests</li>
 *   <li><strong>Validation Annotations:</strong> Bean validation annotations for parameter validation</li>
 *   <li><strong>Pagination Support:</strong> Built-in pagination and sorting parameters</li>
 * </ul>
 * 
 * <p><strong>Features:</strong></p>
 * <ul>
 *   <li>Generates RequestParam classes with proper naming (DomainNameRequestParam)</li>
 *   <li>Includes Bean Validation annotations (@NotNull, @Size, @Pattern, etc.)</li>
 *   <li>Supports pagination with page and size parameters</li>
 *   <li>Supports sorting with sort parameters</li>
 *   <li>Configurable package structure for RequestParam classes</li>
 *   <li>Automatic import management for generated classes</li>
 *   <li>Swagger3 annotations for API documentation</li>
 *   <li>Date range query support for LocalDateTime fields</li>
 * </ul>
 * 
 * <p><strong>Configuration Properties:</strong></p>
 * <ul>
 *   <li><code>requestParamPackage</code> - Target package for RequestParam classes (default: model.param)</li>
 *   <li><code>requestParamTargetProject</code> - Target project path for RequestParam classes (default: src/main/java)</li>
 *   <li><code>enableValidation</code> - Enable Bean Validation annotations (default: true)</li>
 *   <li><code>enablePagination</code> - Enable pagination support (default: true)</li>
 *   <li><code>enableSorting</code> - Enable sorting support (default: true)</li>
 *   <li><code>enableSwagger</code> - Enable Swagger3 annotations (default: true)</li>
 *   <li><code>enableDateRange</code> - Enable date range queries for LocalDateTime fields (default: true)</li>
 *   <li><code>swaggerDescriptionSuffix</code> - Suffix for class descriptions (default: " Request Parameters")</li>
 * </ul>
 * 
 * <p><strong>Usage Example:</strong></p>
 * <pre>
 * &lt;plugin type="cloud.catfish.mbg.plugin.RequestParamGeneratorPlugin"&gt;
 *     &lt;property name="requestParamPackage" value="cloud.catfish.mbg.model.param"/&gt;
 *     &lt;property name="requestParamTargetProject" value="src/main/java"/&gt;
 *     &lt;property name="enableValidation" value="true"/&gt;
 *     &lt;property name="enablePagination" value="true"/&gt;
 *     &lt;property name="enableSorting" value="true"/&gt;
 *     &lt;property name="enableSwagger" value="true"/&gt;
 *     &lt;property name="enableDateRange" value="true"/&gt;
 *     &lt;property name="swaggerDescriptionSuffix" value=" Request Parameters"/&gt;
 * &lt;/plugin&gt;
 * </pre>
 * 
 * <p><strong>Generated RequestParam Example:</strong></p>
 * <pre>
 * &#64;Data
 * &#64;Schema(description = "User Request Parameters")
 * public class UserRequestParam {
 *     &#64;Schema(description = "User ID")
 *     private Long id;
 *     
 *     &#64;Size(max = 50, message = "Username cannot exceed 50 characters")
 *     &#64;Schema(description = "User login name")
 *     private String username;
 *     
 *     &#64;Email(message = "Invalid email format")
 *     &#64;Schema(description = "User email address")
 *     private String email;
 *     
 *     &#64;Schema(description = "Creation time start range")
 *     private LocalDateTime createTimeStart;
 *     
 *     &#64;Schema(description = "Creation time end range")
 *     private LocalDateTime createTimeEnd;
 *     
 *     // Pagination support
 *     &#64;Min(value = 1, message = "Page number must be greater than 0")
 *     &#64;Schema(description = "Page number (starting from 1)", example = "1")
 *     private Integer page = 1;
 *     
 *     &#64;Min(value = 1, message = "Page size must be greater than 0")
 *     &#64;Max(value = 100, message = "Page size cannot exceed 100")
 *     &#64;Schema(description = "Page size", example = "10")
 *     private Integer size = 10;
 *     
 *     &#64;Schema(description = "Sort field and direction (e.g., 'id,desc' or 'username,asc')")
 *     private String sort;
 *     
 *     // Getters and setters are automatically generated by &#64;Data annotation
 * }
 * </pre>
 * 
 * <p><strong>Note:</strong> Field descriptions are automatically extracted from database column comments.
 * If no column comment is available, a readable description is generated from the field name.
 * LocalDateTime fields automatically include start/end range parameters for date range queries.</p>
 * 
 * @author MyBatis Generator Plugin
 * @version 1.0
 * @since Java 8
 */
public class RequestParamGeneratorPlugin extends PluginAdapter {

    // Configuration property keys
    private static final String REQUEST_PARAM_PACKAGE = "requestParamPackage";
    private static final String REQUEST_PARAM_TARGET_PROJECT = "requestParamTargetProject";
    private static final String ENABLE_VALIDATION = "enableValidation";
    private static final String ENABLE_PAGINATION = "enablePagination";
    private static final String ENABLE_SORTING = "enableSorting";
    private static final String ENABLE_SWAGGER = "enableSwagger";
    private static final String ENABLE_DATE_RANGE = "enableDateRange";
    private static final String SWAGGER_DESCRIPTION_SUFFIX = "swaggerDescriptionSuffix";

    // Default values
    private static final String DEFAULT_REQUEST_PARAM_PACKAGE_SUFFIX = ".param";
    private static final String DEFAULT_TARGET_PROJECT = "src/main/java";
    private static final String REQUEST_PARAM_SUFFIX = "RequestParam";

    // Import constants
    private static final String SWAGGER_SCHEMA_CLASS = "io.swagger.v3.oas.annotations.media.Schema";
    private static final String DEFAULT_SWAGGER_DESCRIPTION_SUFFIX = " Request Parameters";

    // Validation annotation constants
    private static final String NOT_NULL_CLASS = "jakarta.validation.constraints.NotNull";
    private static final String SIZE_CLASS = "jakarta.validation.constraints.Size";
    private static final String MIN_CLASS = "jakarta.validation.constraints.Min";
    private static final String MAX_CLASS = "jakarta.validation.constraints.Max";
    private static final String EMAIL_CLASS = "jakarta.validation.constraints.Email";
    private static final String PATTERN_CLASS = "jakarta.validation.constraints.Pattern";

    // Date/Time format constants
    private static final String LOCALDATETIME_TYPE = "LocalDateTime";

    // Configuration fields
    private String requestParamPackage;
    private String requestParamTargetProject = DEFAULT_TARGET_PROJECT;
    private boolean enableValidation = true;
    private boolean enablePagination = true;
    private boolean enableSorting = true;
    private boolean enableSwagger = true;
    private boolean enableDateRange = true;
    private String swaggerDescriptionSuffix = DEFAULT_SWAGGER_DESCRIPTION_SUFFIX;

    @Override
    public boolean validate(List<String> warnings) {
        // Parse configuration properties
        parseConfigurationProperties();
        
        // Set default package if not specified
        if (requestParamPackage == null || requestParamPackage.trim().isEmpty()) {
            String modelPackage = context.getJavaModelGeneratorConfiguration().getTargetPackage();
            requestParamPackage = modelPackage + DEFAULT_REQUEST_PARAM_PACKAGE_SUFFIX;
        }
        
        return true;
    }

    /**
     * Parses configuration properties from the plugin configuration.
     */
    private void parseConfigurationProperties() {
        if (properties != null) {
            requestParamPackage = properties.getProperty(REQUEST_PARAM_PACKAGE);
            requestParamTargetProject = properties.getProperty(REQUEST_PARAM_TARGET_PROJECT, DEFAULT_TARGET_PROJECT);
            enableValidation = Boolean.parseBoolean(properties.getProperty(ENABLE_VALIDATION, "true"));
            enablePagination = Boolean.parseBoolean(properties.getProperty(ENABLE_PAGINATION, "true"));
            enableSorting = Boolean.parseBoolean(properties.getProperty(ENABLE_SORTING, "true"));
            enableSwagger = Boolean.parseBoolean(properties.getProperty(ENABLE_SWAGGER, "true"));
            enableDateRange = Boolean.parseBoolean(properties.getProperty(ENABLE_DATE_RANGE, "true"));
            swaggerDescriptionSuffix = properties.getProperty(SWAGGER_DESCRIPTION_SUFFIX, DEFAULT_SWAGGER_DESCRIPTION_SUFFIX);
        }
    }

    @Override
    public boolean modelBaseRecordClassGenerated(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) {
        try {
            generateRequestParamClass(topLevelClass, introspectedTable);
        } catch (IOException e) {
            throw new RuntimeException("Failed to generate RequestParam class for " + 
                topLevelClass.getType().getShortName(), e);
        }
        return true;
    }

    /**
     * Generates the RequestParam class for the given domain class.
     */
    private void generateRequestParamClass(TopLevelClass domainClass, IntrospectedTable introspectedTable) throws IOException {
        String domainClassName = domainClass.getType().getShortName();
        String requestParamClassName = domainClassName + REQUEST_PARAM_SUFFIX;
        
        StringBuilder content = new StringBuilder();
        
        // Package declaration
        content.append("package ").append(requestParamPackage).append(";\n\n");
        
        // Add imports
        addImports(content, domainClass);
        
        // Class-level annotations
        content.append("@Data\n");
        if (enableSwagger) {
            content.append("@Schema(description = \"").append(getClassDescription(domainClassName)).append("\")\n");
        }
        
        // Class declaration
        content.append("public class ").append(requestParamClassName).append(" {\n\n");
        
        // Generate fields from domain class
        List<Field> fields = domainClass.getFields();
        for (Field field : fields) {
            generateRequestParamField(content, field, introspectedTable);
        }
        
        // Add pagination and sorting fields if enabled
        if (enablePagination || enableSorting) {
            addPaginationAndSortingFields(content);
        }
        
        // Note: Getters and setters are automatically generated by @Data annotation
        
        // Close class
        content.append("}\n");
        
        // Write to file
        writeRequestParamFile(content.toString(), requestParamClassName);
    }

    /**
     * Generates a field for the RequestParam class.
     */
    private void generateRequestParamField(StringBuilder content, Field field, IntrospectedTable introspectedTable) {
        String fieldType = field.getType().getShortName();
        String fieldName = field.getName();
        
        // Handle LocalDateTime fields for date range queries
        if (enableDateRange && LOCALDATETIME_TYPE.equals(fieldType)) {
            generateDateRangeFields(content, field, introspectedTable);
            return;
        }
        
        // Add field documentation
        if (enableSwagger) {
            String description = getFieldDescription(field, introspectedTable);
            content.append("    @Schema(description = \"").append(description).append("\")\n");
        }
        
        // Add validation annotations
        if (enableValidation) {
            addValidationAnnotations(content, field, fieldType);
        }
        
        // Regular field declaration
        content.append("    private ").append(fieldType).append(" ").append(fieldName).append(";\n\n");
    }

    /**
     * Generates date range fields for LocalDateTime types.
     */
    private void generateDateRangeFields(StringBuilder content, Field field, IntrospectedTable introspectedTable) {
        String fieldName = field.getName();
        String fieldType = field.getType().getShortName();
        String description = getFieldDescription(field, introspectedTable);
        
        // Start range field
        if (enableSwagger) {
            content.append("    @Schema(description = \"").append(description).append(" start range\")\n");
        }
        content.append("    private ").append(fieldType).append(" ").append(fieldName).append("Start;\n\n");
        
        // End range field
        if (enableSwagger) {
            content.append("    @Schema(description = \"").append(description).append(" end range\")\n");
        }
        content.append("    private ").append(fieldType).append(" ").append(fieldName).append("End;\n\n");
    }

    /**
     * Adds validation annotations based on field type and database constraints.
     */
    private void addValidationAnnotations(StringBuilder content, Field field, String fieldType) {
        // Add @Size for String fields
        if ("String".equals(fieldType)) {
            content.append("    @Size(max = 255, message = \"").append(field.getName())
                   .append(" cannot exceed 255 characters\")\n");
        }
        
        // Add @Email for email-like fields
        if (field.getName().toLowerCase().contains("email")) {
            content.append("    @Email(message = \"Invalid email format\")\n");
        }
    }

    /**
     * Adds pagination and sorting fields.
     */
    private void addPaginationAndSortingFields(StringBuilder content) {
        content.append("    // Pagination and sorting support\n");
        
        if (enablePagination) {
            // Page field
            if (enableSwagger) {
                content.append("    @Schema(description = \"Page number (starting from 1)\", example = \"1\")\n");
            }
            if (enableValidation) {
                content.append("    @Min(value = 1, message = \"Page number must be greater than 0\")\n");
            }
            content.append("    private Integer page = 1;\n\n");
            
            // Size field
            if (enableSwagger) {
                content.append("    @Schema(description = \"Page size\", example = \"10\")\n");
            }
            if (enableValidation) {
                content.append("    @Min(value = 1, message = \"Page size must be greater than 0\")\n");
                content.append("    @Max(value = 100, message = \"Page size cannot exceed 100\")\n");
            }
            content.append("    private Integer size = 10;\n\n");
        }
        
        if (enableSorting) {
            // Sort field
            if (enableSwagger) {
                content.append("    @Schema(description = \"Sort field and direction (e.g., 'id,desc' or 'username,asc')\")\n");
            }
            content.append("    private String sort;\n\n");
        }
    }

    // Getter and setter generation methods removed - using @Data annotation instead







    /**
     * Adds necessary imports to the generated class.
     */
    private void addImports(StringBuilder content, TopLevelClass domainClass) {
        // Always add basic imports
        content.append("import lombok.Data;\n");
        
        if (enableSwagger) {
            content.append("import ").append(SWAGGER_SCHEMA_CLASS).append(";\n");
        }
        
        // Add validation imports if enabled
        if (enableValidation) {
            content.append("import ").append(SIZE_CLASS).append(";\n");
            content.append("import ").append(MIN_CLASS).append(";\n");
            content.append("import ").append(MAX_CLASS).append(";\n");
            content.append("import ").append(EMAIL_CLASS).append(";\n");
        }
        
        // Check if we need LocalDateTime imports
        boolean hasLocalDateTime = domainClass.getFields().stream()
            .anyMatch(field -> LOCALDATETIME_TYPE.equals(field.getType().getShortName()));
        
        if (hasLocalDateTime && enableDateRange) {
            content.append("import java.time.LocalDateTime;\n");
        }
        
        content.append("\n");
    }

    /**
     * Gets the class description for Swagger documentation.
     */
    private String getClassDescription(String domainClassName) {
        return domainClassName + swaggerDescriptionSuffix;
    }

    /**
     * Gets the field description from database column comments or generates one from field name.
     */
    private String getFieldDescription(Field field, IntrospectedTable introspectedTable) {
        String fieldName = field.getName();
        
        // Try to get description from database column comment
        for (IntrospectedColumn column : introspectedTable.getAllColumns()) {
            if (column.getJavaProperty().equals(fieldName)) {
                String remarks = column.getRemarks();
                if (remarks != null && !remarks.trim().isEmpty()) {
                    return remarks.trim();
                }
                break;
            }
        }
        
        // Generate description from field name if no column comment
        return generateDescriptionFromFieldName(fieldName);
    }

    /**
     * Generates a readable description from a field name.
     */
    private String generateDescriptionFromFieldName(String fieldName) {
        // Convert camelCase to readable text
        StringBuilder description = new StringBuilder();
        for (int i = 0; i < fieldName.length(); i++) {
            char c = fieldName.charAt(i);
            if (i > 0 && Character.isUpperCase(c)) {
                description.append(" ");
            }
            if (i == 0) {
                description.append(Character.toUpperCase(c));
            } else {
                description.append(Character.toLowerCase(c));
            }
        }
        return description.toString();
    }

    /**
     * Writes the RequestParam class content to a file.
     */
    private void writeRequestParamFile(String content, String className) throws IOException {
        String packagePath = requestParamPackage.replace('.', File.separatorChar);
        String targetPath = requestParamTargetProject + File.separator + packagePath;
        
        // Create directories if they don't exist
        File targetDir = new File(targetPath);
        if (!targetDir.exists()) {
            targetDir.mkdirs();
        }
        
        // Write the file
        String fileName = className + ".java";
        File file = new File(targetDir, fileName);
        
        try (FileWriter writer = new FileWriter(file)) {
            writer.write(content);
        }
    }
}